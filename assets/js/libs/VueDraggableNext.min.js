import Sortable from"./sortable.esm.js";import{defineComponent,h,resolveComponent}from"./vue-esm.js";function getConsole(){return"undefined"!=typeof window?window.console:global.console}const console=getConsole();function cached(e){const t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}const regex=/-(\w)/g,camelize=cached(e=>e.replace(regex,(e,t)=>t?t.toUpperCase():""));function removeNode(e){null!==e.parentElement&&e.parentElement.removeChild(e)}function insertNodeAt(e,t,n){const o=0===n?e.children[0]:e.children[n-1].nextSibling;e.insertBefore(t,o)}function computeVmIndex(e,t){return Object.values(e).indexOf(t)}function computeIndexes(e,t,n,o){if(!e)return[];const i=Object.values(e),s=t.length-o;return[...t].map((e,t)=>t>=s?i.length:i.indexOf(e))}function emit(e,t){this.$nextTick(()=>this.$emit(e.toLowerCase(),t))}function delegateAndEmit(e){return t=>{null!==this.realList&&this["onDrag"+e](t),emit.call(this,e,t)}}function isTransitionName(e){return["transition-group","TransitionGroup"].includes(e)}function isTransition(e){if(!e||1!==e.length)return!1;const[{type:t}]=e;return!!t&&isTransitionName(t.name)}function getComponentAttributes(e,t){return t?Object.assign(Object.assign({},t.props),t.attrs):e}const eventsListened=["Start","Add","Remove","Update","End"],eventsToEmit=["Choose","Unchoose","Sort","Filter","Clone"],readonlyProperties=["Move",...eventsListened,...eventsToEmit].map(e=>"on"+e);let draggingElement=null;const props={options:Object,list:{type:Array,required:!1,default:null},noTransitionOnDrag:{type:Boolean,default:!1},clone:{type:Function,default:e=>e},tag:{type:String,default:"div"},move:{type:Function,default:null},componentData:{type:Object,required:!1,default:null},component:{type:String,default:null},modelValue:{type:Array,required:!1,default:null}};export const VueDraggableNext=defineComponent({name:"VueDraggableNext",inheritAttrs:!1,emits:["update:modelValue","move","change",...eventsListened.map(e=>e.toLowerCase()),...eventsToEmit.map(e=>e.toLowerCase())],props:props,data:()=>({transitionMode:!1,noneFunctionalComponentMode:!1,headerOffset:0,footerOffset:0,_sortable:{},visibleIndexes:[],context:{}}),render(){const e=this.$slots.default?this.$slots.default():null,t=getComponentAttributes(this.$attrs,this.componentData);return e?(this.transitionMode=isTransition(e),h(this.getTag(),t,e)):h(this.getTag(),t,[])},created(){null!==this.list&&null!==this.modelValue&&console.error("list props are mutually exclusive! Please set one.")},mounted(){const e={};eventsListened.forEach(t=>{e["on"+t]=delegateAndEmit.call(this,t)}),eventsToEmit.forEach(t=>{e["on"+t]=emit.bind(this,t)});const t=Object.keys(this.$attrs).reduce((e,t)=>(e[camelize(t)]=this.$attrs[t],e),{}),n=Object.assign({},t,e,{onMove:(e,t)=>this.onDragMove(e,t)});!("draggable"in n)&&(n.draggable=">*");const o=1===this.$el.nodeType?this.$el:this.$el.parentElement;this._sortable=new Sortable(o,n),o.__draggable_component__=this,this.computeIndexes()},beforeUnmount(){try{void 0!==this._sortable&&this._sortable.destroy()}catch(e){}},computed:{realList(){return this.list?this.list:this.modelValue}},watch:{$attrs:{handler(e){this.updateOptions(e)},deep:!0},realList(){this.computeIndexes()}},methods:{getTag(){return this.component?resolveComponent(this.component):this.tag},updateOptions(e){for(var t in e){const n=camelize(t);-1===readonlyProperties.indexOf(n)&&this._sortable.option(n,e[t])}},getChildrenNodes(){return this.$el.children},computeIndexes(){this.$nextTick(()=>{this.visibleIndexes=computeIndexes(this.getChildrenNodes(),this.$el.children,this.transitionMode,this.footerOffset)})},getUnderlyingVm(e){const t=computeVmIndex(this.getChildrenNodes()||[],e);return-1===t?null:{index:t,element:this.realList[t]}},emitChanges(e){this.$nextTick(()=>{this.$emit("change",e)})},alterList(e){if(this.list)return void e(this.list);const t=[...this.modelValue];e(t),this.$emit("update:modelValue",t)},spliceList(){this.alterList(e=>e.splice(...arguments))},updatePosition(e,t){this.alterList(n=>n.splice(t,0,n.splice(e,1)[0]))},getVmIndex(e){const t=this.visibleIndexes,n=t.length;return e>n-1?n:t[e]},getComponent(){return this.$slots.default?this.$slots.default()[0].componentInstance:null},resetTransitionData(e){if(!this.noTransitionOnDrag||!this.transitionMode)return;this.getChildrenNodes()[e].data=null;const t=this.getComponent();t.children=[],t.kept=void 0},onDragStart(e){this.context=this.getUnderlyingVm(e.item),this.context&&(e.item._underlying_vm_=this.clone(this.context.element),draggingElement=e.item)},onDragAdd(e){const t=e.item._underlying_vm_;if(void 0===t)return;removeNode(e.item);const n=this.getVmIndex(e.newIndex);this.spliceList(n,0,t),this.computeIndexes();const o={element:t,newIndex:n};this.emitChanges({added:o})},onDragRemove(e){if(insertNodeAt(this.$el,e.item,e.oldIndex),"clone"===e.pullMode)return void removeNode(e.clone);if(!this.context)return;const t=this.context.index;this.spliceList(t,1);const n={element:this.context.element,oldIndex:t};this.resetTransitionData(t),this.emitChanges({removed:n})},onDragUpdate(e){removeNode(e.item),insertNodeAt(e.from,e.item,e.oldIndex);const t=this.context.index,n=this.getVmIndex(e.newIndex);this.updatePosition(t,n);const o={element:this.context.element,oldIndex:t,newIndex:n};this.emitChanges({moved:o})},updateProperty(e,t){e.hasOwnProperty(t)&&(e[t]+=this.headerOffset)},onDragMove(e,t){const n=this.move;if(!n||!this.realList)return!0;const o=this.getRelatedContextFromMoveEvent(e),i=this.context,s=this.computeFutureIndex(o,e);return Object.assign(i,{futureIndex:s}),n(Object.assign({},e,{relatedContext:o,draggedContext:i}),t)},onDragEnd(){this.computeIndexes(),draggingElement=null},getTrargetedComponent:e=>e.__draggable_component__,getRelatedContextFromMoveEvent({to:e,related:t}){const n=this.getTrargetedComponent(e);if(!n)return{component:n};const o=n.realList,i={list:o,component:n};if(e!==t&&o&&n.getUnderlyingVm){const e=n.getUnderlyingVm(t);if(e)return Object.assign(e,i)}return i},computeFutureIndex(e,t){const n=[...t.to.children].filter(e=>"none"!==e.style.display);if(0===n.length)return 0;const o=n.indexOf(t.related),i=e.component.getVmIndex(o);return-1!==n.indexOf(draggingElement)||!t.willInsertAfter?i:i+1}}});